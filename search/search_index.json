{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"#what-is-dynamic-typing","title":"What is Dynamic Typing?","text":"<p>For the 2025 Annual Python Discord Codejam, the Monumental Monsteras put together the incredibly fun and totally not at all frustrating words per minute testing site, \"Dynamic Typing\". Dynamic Typing was built to fit the theme \"wrong tool for the job\", where the user is able to test their words per minute score, but they were not able to use their keyboard. Instead, the user has to choose how they would like to complete their typing test from the available options, all of which are very much the wrong tool for the job.</p>"},{"location":"#framework","title":"Framework","text":"<p>We chose the NiceGUI framework to build our frontend, including the user interface and the input methods, which were majorly ran on built in-modules of NiceGUI. We chose NiceGUI because of its easy-to-use modules that allow manipulation of almost any HTML element with CSS, as well as its seamless implementation of Tailwind CSS and the Quasar properties.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-uv-recommended","title":"Using uv (recommended)","text":"<p>The recommended way to run the project is using uv.</p> <p>If you do not have uv installed, see the installation guide.</p> <pre><code>$ git clone https://github.com/Mannyvv/cj25-monumental-monsteras-team-repo.git\n$ cd cj25-monumental-monsteras-team-repo.git\n$ uv run src/main.py\n</code></pre>"},{"location":"#without-uv","title":"Without uv","text":"<pre><code>$ git clone https://github.com/Mannyvv/cj25-monumental-monsteras-team-repo.git\n$ cd cj25-monumental-monsteras-team-repo.git\n$ py -3.12 -m venv .venv\n$ py -m pip install .\n$ py src/main.py\n</code></pre>"},{"location":"#contributions","title":"Contributions","text":"<p>Everyone - Laid out the idea and implementation.</p> <p>Manny - Team leader, Audio Input Method</p> <p>Kam - Input View, Input Method Protocol, WPM Testing Functionality, and Platformer Input Method</p> <p>GiGaGon - WASD Keyboard Input Method, Project Setup, Input Method Configuration</p> <p>Skye - User Interface and General Web Design</p> <p>Tarheel - Color Picker Input Method</p>"},{"location":"audio_style_input/","title":"DJ Keyboard","text":""},{"location":"audio_style_input/#audio-input-method","title":"Audio Input Method","text":""},{"location":"audio_style_input/#introduction","title":"Introduction","text":"<p>This component is a fun and kind of annoying typing test. It works and gets the job done, but it definitely is the wrong tool for the job. Fitting right into the code jam theme of this year.</p> <p>It highlights the absurdity of using a vinyl record interface to type text. Users interact with the typing test by using the vinyl record controls like play, pause, skip forward/backward, and other buttons to select characters.</p> <p>When the user presses play, a song begins and characters are displayed in sequence as the music plays. Users watch the characters and, when they see the one they want, they press record to send it to the typing test component. Characters can be lowercase letters, uppercase letters, or punctuation, and the user can cycle through three different tracks, each corresponding to a type of character. </p>"},{"location":"audio_style_input/#user-interface","title":"User Interface","text":""},{"location":"audio_style_input/#starting-page","title":"Starting Page","text":""},{"location":"audio_style_input/#initial-setup","title":"Initial Setup","text":""},{"location":"audio_style_input/#buttons","title":"Buttons","text":""},{"location":"audio_style_input/#letter-pill","title":"Letter Pill","text":""},{"location":"audio_style_input/#styling","title":"Styling","text":"<ul> <li><code>color_style.ColorStyle</code> \u2014 defines a consistent theming system for the app. </li> </ul>"},{"location":"audio_style_input/#detailed-flow","title":"Detailed Flow","text":"<ul> <li>User clicks the play button \u2192 triggers vinyl to spin, characters to cycle</li> <li>Letter spinner updates asynchronously \u2192 new letter is displayed in the UI.  </li> <li><code>select_char()</code> fires when the record button is pressed \u2192 sends the current string of typed characters with the new character to the Typing Test Component via <code>TextUpdateCallback</code>.  </li> <li>Typing Test Component updates the sentence display \u2192 shows which letters were typed correctly or incorrectly and tracks the user's position in the sentence.  </li> <li>WPM/WPH is calculated only after the user reaches the end of the sentence with correct typing.  </li> <li>UI updates \u2192 record animation and letter chip continue spinning, creating the \u201cwrong tool for the job\u201d experience.</li> </ul>"},{"location":"audio_style_input/#demo","title":"Demo","text":"Button Usage Complete a Sentence Sound Effects - Play and Turn On Sound\ud83d\udd0a!"},{"location":"audio_style_input/#code","title":"Code","text":""},{"location":"audio_style_input/#core-libraries-classes","title":"Core Libraries &amp; Classes","text":"<p>This component uses a combination of a main framework, utility libraries, and interface classes. Below is a breakdown of the most important parts.</p>"},{"location":"audio_style_input/#main-framework","title":"Main Framework","text":"<ul> <li><code>NiceGUI</code> \u2014 provides web-based UI elements, layouts, and events, handling interactivity, buttons, audio controls, and visual updates for the spinning record and character spinner. NiceGUI components also allowed me to play music and sounds when needed.</li> </ul>"},{"location":"audio_style_input/#utility-library","title":"Utility Library","text":"<ul> <li><code>Asyncio</code> \u2014 used to create a timer so the vinyl record image can spin, the characters cycle through their sets, and buttons can be monitored for actions such as rewind, forward, pause, and play. Also used to play sounds when buttons are pressed.</li> </ul>"},{"location":"audio_style_input/#interface-classes","title":"Interface Classes","text":"<ul> <li><code>input_method_proto.IInputMethod</code> \u2014 the interface that this component implements to connect with the typing test module.</li> <li><code>TextUpdateCallback</code> \u2014 a function passed from the typing test module that allows this component to send selected characters back to the tester.</li> </ul>"},{"location":"audio_style_input/#more-in-depth","title":"More In Depth","text":"<ul> <li><code>cycle_char_select()</code> \u2014 Cycles between uppercase, lowercase, and punctuation character sets.  </li> <li><code>spin_continuous()</code> \u2014 Runs asynchronously to continuously rotate the vinyl record.  </li> <li><code>letter_spinner_task()</code> \u2014 Updates the character label asynchronously, cycling through the selected set.  </li> <li><code>start_spinning()</code> / <code>stop_spinning()</code> \u2014 Controls vinyl record rotation.  </li> <li><code>speed_boost()</code> \u2014 Temporarily increases spin speed for animations like fast-forward or rewind.  </li> <li><code>toggle_play_pause()</code> / <code>play_pause_handler()</code> \u2014 Handles play/pause logic for music and character spinner.  </li> <li><code>_select_letter_handler()</code> \u2014 Handles letter selection and triggers the text callback.  </li> <li><code>_delete_letter_handler()</code> \u2014 Deletes the last character in the user text.  </li> <li><code>_add_space_handler()</code> \u2014 Adds a space to the user text.  </li> <li><code>forward_3()</code> / <code>rewind_3()</code> \u2014 Skip multiple letters with accompanying sound effects and spin animations.  </li> <li><code>setup_buttons()</code> \u2014 Creates NiceGUI buttons and binds them to event handlers.</li> </ul> <pre><code>classDiagram\n  IInputMethod &lt;|.. AudioEditorComponent\n\n  class AudioEditorComponent {\n    +__init__()\n    +create_intro_card() tuple[ui.card, ui.button]\n    +create_main_content() tuple[ui.column, ui.image, ui.chip, ui.row, ui.row]\n    +setup_buttons()\n    +cycle_char_select()\n    +spin_continuous()\n    +letter_spinner_task()\n    +start_spinning(clockwise: bool)\n    +stop_spinning()\n    +speed_boost(final_direction: int)\n    +toggle_play_pause()\n    +play_pause_handler()\n    +on_play()\n    +on_pause()\n    +play_rewind_sound()\n    +play_fast_forward_sound()\n    +forward_3()\n    +rewind_3()\n    -_select_letter_handler()\n    +start_audio_editor()\n    +on_text_update(callback: TextUpdateCallback)\n    +select_char(char: str)\n    -_delete_letter_handler(char: str)\n    -_add_space_handler(char: str)\n  }\n\n  class IInputMethod {\n    +on_text_update(callback: TextUpdateCallback)\n  }\n</code></pre> <p>Logic Flow </p> (Click to Englarge)"},{"location":"color_mixer_input/","title":"Color Picker","text":""},{"location":"color_mixer_input/#color-mixer-input-method","title":"Color Mixer Input Method","text":""},{"location":"color_mixer_input/#intro","title":"Intro","text":"<p>The <code>Color Picker</code> page offers the user a frustrating typing interface, possibly triggering bouts of synesthesia. Users are tasked with typing a randomly generated phrase, but first they have to find the letters...</p>"},{"location":"color_mixer_input/#user-demo","title":"User Demo","text":"<p>Below is a brief demo of how a user may interact with the page. </p>"},{"location":"color_mixer_input/#_1","title":"Color Picker","text":"<p>The first few user inputs are described below:</p> <ol> <li>User clicks the spectrum in a region corresponding to the color <code>lime</code>, which outputs the letter <code>l</code></li> <li>User toggles the CAPS LOCK on. Note that this does not capitalize the L.</li> <li>User confirms the letter L</li> <li>Note that <code>l</code> is highlighted in red in the target text since it is the incorrect character</li> <li>The user clicks black to input backspace and remove the character <code>l</code></li> <li>The user selects <code>lime</code> again which now inputs <code>L</code>.</li> <li>The user confirms the input</li> <li>The user changes the color hues using the spectrum meter</li> <li>The user removes the <code>CAPS LOCK</code>, selects <code>orange</code>, then confirms the letter <code>o</code></li> </ol>"},{"location":"color_mixer_input/#main-ui","title":"Main UI","text":"<p>Users will see the page below:</p> <p></p>"},{"location":"color_mixer_input/#typing-with-the-color-mixer","title":"Typing with the Color Mixer","text":""},{"location":"color_mixer_input/#_2","title":"Color Picker","text":"<p>The color mixer is the main keyboard. Users can access all 26 letters, backspace, and space by clicking a color. Special characters and capital letters are accessible via the buttons to the right of the color mixer. The mixer panel displays  color values in hexadecimal or (Red,Green,Blue). See the image below.</p>"},{"location":"color_mixer_input/#_3","title":"Color Picker","text":""},{"location":"color_mixer_input/#_4","title":"Color Picker","text":"<p>Colors correspond to intuitive letters where possible, but some letters are hard to find...</p>"},{"location":"color_mixer_input/#more-on-typing","title":"More on Typing","text":""},{"location":"color_mixer_input/#letters","title":"Letters","text":"<p>In order to type a letter the user</p> <ol> <li>Clicks a color on the color palette</li> <li>Clicks the CONFIRM LETTER button</li> </ol> <p>Letters will not appear in the target output prior to confirmation!!!</p>"},{"location":"color_mixer_input/#special-characters","title":"Special Characters","text":"<ul> <li>To type the special characters <code>. ! , ?</code> press the corresponding button. </li> <li>The <code>CAPS LOCK</code> switch controls letter case, which the user can toggle. It defaults to the off position (white) and  turns on (blue) when clicked.</li> </ul>"},{"location":"color_mixer_input/#more-details","title":"More Details","text":"<p>The first letter of the selected color determines the selected letter. Black and white correspond to backspace  and space inputs, respectively. </p> <p>Letters must be confirmed using the CONFIRM LETTER button. Special characters, backspace,and space inputs will  automatically display in the target output.</p>"},{"location":"color_mixer_input/#help-text","title":"Help Text","text":"<p>Upon clicking a color, the user sees the name of the color selected and the corresponding letter (see image below).  This information is displayed on the right side of the color panel, above the special character buttons. This text is meant to aid the user. Users must confirm letters before they are officially typed. Special characters are automatically  confirmed and displayed, including space and backspace inputs. </p> <p>In the image below the user has clicked on the color fuchsia which corresponds to the letter f.</p> <p></p> <p>Clicking <code>HEX</code> or <code>RGB</code> in the header above changes whether the color value displays as a hex code or as  Red-Green-Blue color intensities. This does not affect the color name display text.</p>"},{"location":"color_mixer_input/#more-on-the-color-mixer","title":"More on the Color Mixer","text":"<p>The color mixer contains three modes. Spectrum, Tune, and Palette. The image above displays Spectrum mode, which  is the default mode.</p>"},{"location":"color_mixer_input/#spectrum","title":"Spectrum","text":"<p>Users selects colors by clicking on the map. Users can adjust the spectrum meter to access various hues. Black and white  are accessible on all levels. </p>"},{"location":"color_mixer_input/#tune","title":"Tune","text":"<p>Users select colors by adjusting the intensities of Red, Green, and Blue. The values can be adjusted by dragging the bar for a particular color, or by typing an integer (0 to 255 inclusive). The Tuner icon is circled in orange below. Click the icon to switch to this view mode.</p>"},{"location":"color_mixer_input/#_5","title":"Color Picker","text":""},{"location":"color_mixer_input/#palette","title":"Palette","text":"<p>Users select colors by clicking within the color palette. The Palette icon is circled in orange in the image below.  Click it to switch to this view mode.</p>"},{"location":"color_mixer_input/#_6","title":"Color Picker","text":"<p>Note: Spectrum mode is recommended.</p>"},{"location":"color_mixer_input/#targets-statistics-and-cues","title":"Targets, statistics, and cues","text":"<p>The target sentence is displayed in green text. The top of the page also displays a timer and  typing statistics. The timer begins when the first input is confirmed. Users receive visual clues indicating typing  accuracy. Correct inputs are highlighted in green while incorrect inputs are highlighted in red. See the two images  below.</p>"},{"location":"color_mixer_input/#_7","title":"Color Picker","text":""},{"location":"color_mixer_input/#_8","title":"Color Picker","text":""},{"location":"color_mixer_input/#implementation","title":"Implementation","text":"<p>The color input page was created by implementing the class <code>ColorInputComponent</code>. </p> <p>The <code>niceGUI</code> framework was beneficial in implementing the page and class, especially in constructing the page layout. The color mixer, CAPS LOCK, and special character elements were all created using functionality native to <code>niceGUI</code>.  In particular, the color-mixer came from the <code>Quasar color-picker</code> component. Color-picker properties were tweaked to  optimize the page, for example ensuring that the color picker did not minimize. However, many important features were  readily available. Further styling of the page elements was achieved using standard <code>CSS</code> and <code>Tailwind</code> properties.</p> <p>The class consists of 13 methods used to construct the page, and an additional method, <code>color_input_page</code> that was used  for testing the class separately from the main program.</p> <p>The class <code>__init__</code> method sets various attributes or performs methods needed to build the page, track user inputs, and map colors to text. This includes but is not limited to</p> <ul> <li>a callback attribute allowing the class to interface with the WPM Tester class</li> <li>the current color selected by the user</li> <li>the current character selected by the user</li> <li>the character confirmed by the user</li> <li>ui elements (e.g. color picker and character buttons)</li> <li>a color dictionary mapping colors names to unique letters or inputs</li> </ul> <p>In particular, the callback attribute plays a central role in the construction of the class. Rather than using <code>ui.page</code> decorators to generate individual classes, the project was designed to allow all input methods to work through the WPM tester. This was achieved using the <code>on_text_update</code> method which allowed the WPM tester to communicate with the class whenever text should be updated. Implementing the <code>on_text_update</code> method ensured that the <code>ColorInputComponent</code> satisfied the requirements of the protocol defined in <code>input_method_proto.py</code>. As previously discussed implementing the specific page methods as protocols allowed for greater cohesion across the project.</p> <p>The code handles user click events and establishes the backend logic necessary to map colors to text. For each clickable page element the class contains uses custom <code>handler</code> and <code>update</code> methods to update the backend and page state after a  user click. The <code>update_helper_text</code> and <code>update_confirmation_text</code> methods serve as helpers to the  <code>special_character_handler</code>, <code>confirm_letter_handler</code>, <code>color_handler</code>, and <code>shift_handler</code> methods. </p> <p>The methods <code>create_ui_content</code> and <code>setup_ui_buttons</code> set up the page layout and button positions, and create the  specific UI elements necessary for typing (e.g. color mixer, special character buttons).</p> <p>The <code>find_closest_member</code> method is an important backend functions. Each of the 26 letters, backspace, and space map  to a unique color. This information was stored in the aforementioned dictionary attribute, which contained 28 items.  The RGB/hex code structure permits the user to select up to 16^6, or nearly 16.8 million colors. The  <code>find_closet_member</code> method maps every possible hex code color to one of the 28 colors in the dictionary. Colors were  mapped to the \"closest\" color in the dictionary using their RGB coordinates and the Euclidean distance metric. The class contains two other static methods that serve as helper functions to <code>find_closest_member</code>. The method <code>hex_to_rgb</code>  converts hex_codes to a 3-tuple of RGB values, while <code>color_dist</code> uses the RGB tuples to compute the distance between  two colors</p> <p>The class also uses the <code>string</code> library in base python for easy access to ASCII characters.</p>"},{"location":"core/","title":"Core","text":""},{"location":"core/#core","title":"Core","text":"<p>To bring everything together, we have multiple front-end components that allow each input method to work with the front end seamlessly.</p>"},{"location":"core/#input-view","title":"Input View","text":"<p>This component displays the text for the user to type and updates as the user inputs letters through the input method. It is initialised with the <code>full_text</code> argument, which is the text for the user to type. To interact with it, the input method will call the <code>set_text()</code> method with the output of the input method interaction, resulting in either a green or red box to appear over the letter, symbolising either the correct or incorrect letter being inputted.</p> <p></p>"},{"location":"core/#input-method","title":"Input Method","text":"<p>The four input methods are built as subclasses of the <code>IInputMethod</code> protocol within modules that can be imported into the testing page. The <code>IInputMethod</code> super class requires the subclasses to support a <code>on_text_update(callback)</code> function to react to the user typing in real time.</p> <pre><code>from collections.abc import Callable\nfrom typing import Protocol\n\ntype TextUpdateCallback = Callable[[str], None]\n\n\nclass IInputMethod(Protocol):\n    \"\"\"An interface for any input method renderable in the WPM test page.\"\"\"\n\n    def on_text_update(self, callback: TextUpdateCallback) -&gt; None:\n        \"\"\"Call `callback` every time the user input changes.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"core/#wpm-testing-page","title":"WPM Testing Page","text":"<p>The Words Per Minute (WPM) testing page is initialized in <code>wpm_tester.py</code>. This creates a general user interface frame that the input view and the input method are injected into and displayed.</p> <p> </p>"},{"location":"keyboard_input/","title":"WASD Input","text":""},{"location":"keyboard_input/#wasd-input","title":"WASD Input","text":"<p>This input method is a parody of the inconvenience of text entry in RPG Maker games. Naviage around an on-screen keyboard using wasd + space or arrow keys + enter.</p>"},{"location":"keyboard_input/#playthrough-video","title":"Playthrough video","text":""},{"location":"keyboard_input/#implementation-details","title":"Implementation Details","text":"<p>The keys on the keyboard are stored as a tuple of strings, which must must be rectangular (all strings mut be the same <code>len</code>).</p> <pre><code>KEYBOARD_KEYS: tuple[str, ...] = (\n    \"ABCDEFGabcdefg\",\n    \"HIJKLMNhijklmn\",\n    \"OPQRSTUopqrstu\",\n    \"VWXYZ. vwxyz!\\N{SYMBOL FOR BACKSPACE}\",\n)\n</code></pre> <p><code>\\N{SYMBOL FOR BACKSPACE}</code> is hard-coded to act as backspace instead of entering the literal character.</p> <p>Functionallity is implemented using a keyboard event hook through <code>ui.keyboard(on_key=self.handle_key)</code></p>"},{"location":"platformer_input/","title":"Platformer","text":""},{"location":"platformer_input/#the-platformer-input-method","title":"The platformer input method","text":"<p>Basically, it's a platformer game. You jump around on the platforms to access letters to type. This fits the theme of \"wrong tool for the job\" because it's an absolutely abhorrent way to type, and additionally it uses emojis as tiles just to make it even more torturous.</p>"},{"location":"platformer_input/#how-to-use-it","title":"How to use it","text":"<p>To type a letter, jump and bump your head on one of the letter tiles -- it will input the letter. Note that every time you jump, it inverts the capitalization of the next letter.</p> <p></p>"},{"location":"platformer_input/#how-it-works","title":"How it works","text":"<p>The code is split into three parts. The main component (<code>__init__.py</code>), which is embedded into the actual page, the physics simulation (<code>platformer_simulation.py</code>), which takes the user's input and returns the new positions with gravity and collision, and the renderer (<code>platformer_scene_cmp.py</code>), which is a component that renders the scene and player. There's also the constants file (<code>platformer_constants.py</code>) which is most of the constants throughout the files.</p>"},{"location":"platformer_input/#main-component","title":"Main component","text":"<p>Adds the renderer component and passes messages between the simulation and the renderer, as well as managing some handlers and the capitalization state.</p>"},{"location":"platformer_input/#physics-simulation","title":"Physics simulation","text":"<p>Takes the current keys pressed from the main component, and moves the player accordingly. It also performs collision checks and applies gravity.</p>"},{"location":"platformer_input/#renderer","title":"Renderer","text":"<p>The renderer first renders the whole map, then puts it in a parent element with a fixed size to clip out the stuff outside of the field of view. It always renders the player in the same spot on the canvas, so it can just use the CSS <code>transform</code> property to move the map inverted to where the player is.</p> <p>Fun fact: the original renderer rerendered every 1/3 tile with an individual HTML element. This was super slow, and crashed the app at speeds of around 30 FPS or higher. The new method is both a lot faster and a lot simpler!</p>"},{"location":"platformer_input/#constants-file","title":"Constants file","text":"<p>The only interesting thing here is the world definition. The initial scene is defined as a triple-quoted multiline string where <code>#</code> is a block, spaces are air, and anything else are letters. There's also a function which transforms the scene into a two-dimensional array with each character as a cell.</p>"}]}